/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Gaussian core + exponential tail
// Souvik Das (8/1/2013) Initial implementation (http://arxiv.org/pdf/1603.08591v1.pdf)
// Giovanni Marchiori (30/3/2016) Implemented tail on negative side of distribution and analytic integral

#include "Riostream.h" 

#include "RooGaussExp.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "Math/ProbFuncMathCore.h"

ClassImp(RooGaussExp) 


//_____________________________________________________________________________
RooGaussExp::RooGaussExp(const char *name, const char *title, 
                       RooAbsReal& _m,
                       RooAbsReal& _m0,
                       RooAbsReal& _sigma,
                       RooAbsReal& _alpha) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  m0("m0","m0",this,_m0),
  sigma("sigma","sigma",this,_sigma),
  alpha("alpha","alpha",this,_alpha)
{ 
} 


//_____________________________________________________________________________
RooGaussExp::RooGaussExp(const RooGaussExp& other, const char* name) :  
  RooAbsPdf(other,name), 
  m("m",this,other.m),
  m0("m0",this,other.m0),
  sigma("sigma",this,other.sigma),
  alpha("alpha",this,other.alpha)
{ 
} 


//_____________________________________________________________________________
Double_t RooGaussExp::evaluate() const 
{
   Double_t t=(m-m0)/sigma;
   if (alpha < 0) t = -t;
   Double_t absAlpha = fabs((Double_t)alpha);

   if (t >= -absAlpha)
     return exp(-0.5*t*t);
   else
     return exp(alpha*alpha/2.+absAlpha*t);
} 


//_____________________________________________________________________________
Int_t RooGaussExp::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  if( matchArgs(allVars,analVars,m) )
    return 1;
 
  return 0;
}


//_____________________________________________________________________________
Double_t RooGaussExp::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code==1);
  double result = 0;
   
  double sig = fabs((Double_t)sigma);
  double tmin = (m.min(rangeName)-m0)/sig;
  double tmax = (m.max(rangeName)-m0)/sig;
  double absAlpha = fabs((Double_t)alpha);
  if(alpha < 0) {
    double tmp = tmin;
    tmin = -tmax;
    tmax = -tmp;
  }
  
  if (tmin >= -absAlpha)
    result = gaussianIntegral(tmin, tmax);
  else if (tmax <= -absAlpha)
    result = tailIntegral(tmin, tmax, absAlpha);
  else {
    result += tailIntegral(tmin, -absAlpha, absAlpha);
    result += gaussianIntegral(-absAlpha, tmax);
  }
  return sig*result;
}

//_____________________________________________________________________________
double RooGaussExp::gaussianIntegral(double tmin, double tmax) const
{
  return sqrt(TMath::TwoPi())*(ROOT::Math::gaussian_cdf(tmax) - ROOT::Math::gaussian_cdf(tmin));
}

//_____________________________________________________________________________
double RooGaussExp::tailIntegral(double tmin, double tmax, double alpha) const
{
  double a = exp(0.5*alpha*alpha)/alpha;
  return (a*(exp(alpha*tmax)-exp(alpha*tmin)));
}
