#define TMETree_cxx
// The class definition in TMETree.h has been generated automatically
// by the ROOT utility TTree::MakeSelector(). This class is derived
// from the ROOT class TSelector. For more information on the TSelector
// framework see $ROOTSYS/README/README.SELECTOR or the ROOT User Manual.


// The following methods are defined in this file:
//    Begin():        called every time a loop on the tree starts,
//                    a convenient place to create your histograms.
//    SlaveBegin():   called after Begin(), when on PROOF called only on the
//                    slave servers.
//    Process():      called for each event, in this function you decide what
//                    to read and fill your histograms.
//    SlaveTerminate: called at the end of the loop on the tree, when on PROOF
//                    called only on the slave servers.
//    Terminate():    called at the end of the loop on the tree,
//                    a convenient place to draw/fit your histograms.
//
// To use this file, try the following session on your Tree T:
//
// root> T->Process("TMETree.C")
// root> T->Process("TMETree.C","some options")
// root> T->Process("TMETree.C+")
//

#include "TMETree.h"
#include <TMath.h>
#include <algorithm>
#include <iterator>

void TMETree::LoadCuts()
{
	Int_t sigma=3;
	TFile *fCuts = new TFile("/home/m-wong/tree/al50-cuts.root", "READ");
	SiL_wPP_cutg = (TCutG *)fCuts->Get(Form("hLg_SiL_EvDeltaE_proton_%dsigma", sigma) );
	SiR_wPP_cutg = (TCutG *)fCuts->Get(Form("hLg_SiL_EvDeltaE_proton_%dsigma", sigma) ); //SiR version doesn't exist yet
}
void TMETree::RunQuality()
{
	silver = {9410, 9411, 9412, 9518, 9553, 9607, 9656, 9657, 9659, 9679};
}
void TMETree::ResetValues() {
	tpi_id1 = -1;
	tpi_id2 = -1;
	tpi_id3 = -1;
	t1 = nan("nanl"); 
	t2 = nan("nanl");
	t3 = nan("nanl");
	e1 = nan("nanl");
	e2 = nan("nanl");
	e3 = nan("nanl");
	channel = TString("");
	pid = TString("");
}
TMETree::~TMETree() {
}
void TMETree::Begin(TTree * /*tree*/)
{
	// The Begin() function is called at the start of the query.
	// When running with PROOF Begin() is only called on the client.
	// The tree argument is deprecated (on PROOF 0 is passed).
	TString option = GetOption();
}

void TMETree::SlaveBegin(TTree * /*tree*/)
{
	// The SlaveBegin() function is called after the Begin() function.
	// When running with PROOF SlaveBegin() is called on each slave server.
	// The tree argument is deprecated (on PROOF 0 is passed).
	TString option = GetOption();
	fProofFile = new TProofOutputFile(Form("%s.root", option.Data() ), "M");
	TNamed *out = (TNamed *) fInput->FindObject("PROOF_OUTPUTFILE");
	if (out) fProofFile->SetOutputFileName(out->GetTitle());
	TDirectory *savedir = gDirectory;
	fFile = fProofFile->OpenFile("RECREATE");
	if (fFile && fFile->IsZombie()) SafeDelete(fFile);
	savedir->cd();

	tree = new TTree("tree", "tree");
	tree->Branch("runId", &nRunId);
	tree->Branch("blockId", &nBlockId);
	tree->Branch("tmeId", &nTMEId);
	tree->Branch("channel", &channel);
	tree->Branch("tpi_id1", &tpi_id1);
	tree->Branch("tpi_id2", &tpi_id2);
	tree->Branch("tpi_id3", &tpi_id3);
	tree->Branch("e1", &e1);
	tree->Branch("e2", &e2);
	tree->Branch("e3", &e3);
	tree->Branch("t1", &t1);
	tree->Branch("t2", &t2);
	tree->Branch("t3", &t3);
	tree->Branch("pid", &pid);
	tree->Branch("quality", &quality);
	tree->SetDirectory(fFile);
	tree->AutoSave();
	LoadCuts();
	RunQuality();
}	

Bool_t TMETree::Process(Long64_t entry)
{

	// The Process() function is called for each entry in the tree (or possibly
	// keyed object in the case of PROOF) to be processed. The entry argument
	// specifies which entry in the currently loaded tree is to be processed.
	// When processing keyed objects with PROOF, the object is already loaded
	// and is available via the fObject pointer.
	//
	// This function should contain the \"body\" of the analysis. It can contain
	// simple or elaborate selection criteria, run algorithms on the data
	// of the event and typically fill histograms.
	//
	// The processing can be stopped by calling Abort().
	//
	// Use fStatus to set the return value of TTree::Process().
	//
	// The return value is currently not used.
	TString option = GetOption();
	fReader.SetEntry(entry);
	nRunId = *runId;
	nBlockId = *blockId;
	//assign silver runs
	quality = TString("");
	if(std::find(std::begin(silver), std::end(silver), nRunId) != std::end(silver) ) {
		quality = TString("s");
	}
	nTMEId = *TMEId;
	std::vector<SimplePulse> vSiL1[n_SiL1_channels] = {
		*SiL1_2, *SiL1_3, *SiL1_4, *SiL1_5, *SiL1_6,
		*SiL1_7, *SiL1_8, *SiL1_9, *SiL1_10, *SiL1_11,
		*SiL1_12, *SiL1_13, *SiL1_14, *SiL1_15
	};
	std::vector<SimplePulse> vSiR1[n_SiR1_channels] = {
		*SiR1_1, *SiR1_2, *SiR1_3, *SiR1_4
	};
	std::vector<SimplePulse> vSiT[n_SiT_channels] = {
		*SiT_1, *SiT_2, *SiT_3, *SiT_4
	};
	ResetValues();
	if(SiL3->size() ) {
		for(int i_chn=0 ; i_chn < n_SiL1_channels; i_chn++) {
			if(vSiL1[i_chn].size() ) {
				for(unsigned j=0; j < vSiL1[i_chn].size(); j++) {
					for(unsigned k=0; k < SiL3->size(); k++) {
						tpi_id1 = vSiL1[i_chn].at(j).tpi_id;
						tpi_id2 = SiL3->at(k).tpi_id;
						t1 = vSiL1[i_chn].at(j).tTME;
						t2 = SiL3->at(k).tTME;
						//e1 = vSiL1[i_chn].at(j).E * 0.001; //al100
						e1 = (vSiL1[i_chn].at(j).Amp * 2.056969 + 1.370678) * 0.001; //al50
						e2 = SiL3->at(k).E * 0.001;
						if(option.CompareTo("al50") == 0) {
							e1 = (vSiL1[i_chn].at(j).Amp * 2.056969 + 1.370678) * 0.001; //al50
							t1 = vSiL1[i_chn].at(j).tTME; //al50
						}
						if(SiL_wPP_cutg->IsInside(0.7071 * (TMath::Log10(e1+e2) - TMath::Log10(e1) ), 0.7071 * (TMath::Log10(e1+e2) + TMath::Log10(e1) ) ) ) {
							pid = TString("p");
						} else {
							pid = TString("");
						}
						channel = TString(all_SiL1_channel_names[i_chn]);
						tree->Fill();
					}
				}
			}
		}
	}
	ResetValues();
	if(SiR2->size() ) {
		for(int i_chn=0 ; i_chn < n_SiR1_channels; i_chn++) {
			if(vSiR1[i_chn].size() ) {
				for(unsigned j=0; j < vSiR1[i_chn].size(); j++) {
					for(unsigned k=0; k < SiR2->size(); k++) {
						tpi_id1 = vSiR1[i_chn].at(j).tpi_id;
						tpi_id2 = SiR2->at(k).tpi_id;
						t1 = vSiR1[i_chn].at(j).tTME;
						t2 = SiR2->at(k).tTME;
						e1 = vSiR1[i_chn].at(j).E * 0.001; //al100
						e2 = SiR2->at(k).E * 0.001;
						if(SiR3->size() ) {
							for(unsigned p=0; p < SiR3->size(); p++) {
								tpi_id3 = SiR3->at(p).tpi_id;
								t3 = SiR3->at(p).tTME;
								e3 = SiR3->at(p).E * 0.001;
							}
						}
						if(SiR_wPP_cutg->IsInside(0.7071 * (TMath::Log10(e1+e2) - TMath::Log10(e1) ), 0.7071 * (TMath::Log10(e1+e2) + TMath::Log10(e1) ) ) ) {
							pid = TString("p");
						} else {
							pid = TString("");
						}
						channel = TString(all_SiR1_channel_names[i_chn]);
						tree->Fill();
					}
				}
			}
		}
	}
	ResetValues();
	if(GeLoGain->size() ) {
		for(unsigned i=0; i<GeLoGain->size(); i++) {
			tpi_id1 = GeLoGain->at(i).tpi_id;
			e1 = GeLoGain->at(i).E;
			t1 = GeLoGain->at(i).tTME;
			channel = TString("GeLoGain");
			tree->Fill();
		}
	}
	ResetValues();
	if(GeHiGain->size() ) {
		for(unsigned i=0; i<GeHiGain->size(); i++) {
			tpi_id1 = GeHiGain->at(i).tpi_id;
			e1 = GeHiGain->at(i).E;
			t1 = GeHiGain->at(i).tTME;
			channel = TString("GeHiGain");
			tree->Fill();
		}
	}
	return kTRUE;
}

void TMETree::SlaveTerminate()
{
	// The SlaveTerminate() function is called after all entries or objects
	// have been processed. When running with PROOF SlaveTerminate() is called
	// on each slave server.
   if (fFile) {
      TDirectory *savedir = gDirectory;
      fFile->cd();
      SiL_wPP_cutg->Write();
      SiR_wPP_cutg->Write();
      tree->Write();
      gDirectory = savedir;
      fFile->Close();
      Info("SlaveTerminate", "objects saved into '%s%s': sending related TProofOutputFile ...", fProofFile->GetFileName(), fProofFile->GetOptionsAnchor());
      fProofFile->Print();
      fOutput->Add(fProofFile);
   }

}

void TMETree::Terminate()
{
	// The Terminate() function is the last function to be called during
	// a query. It always runs on the client, it can be used to present
	// the results graphically or save the results to file.
//	try {
//		//Print everything in fOutput
//		TString option = GetOption();
//		fOutputFile = new TFile(Form("%s.root", option.Data() ), "RECREATE");
//		for(TObject* obj: *fOutput) {
//			gDirectory->Add(obj);
//		}
//		fOutputFile->Write();
//	} catch (int e) {
//		cerr << "Exception: " << e << endl;
//	}
}
