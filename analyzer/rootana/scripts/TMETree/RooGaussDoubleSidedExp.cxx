/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Gaussian core + exponential tail on both sides
// Souvik Das (8/1/2013) Initial implementation (http://arxiv.org/pdf/1603.08591v1.pdf)
// Giovanni Marchiori (30/3/2016) Implemented analytic integral

#include "Riostream.h" 

#include "RooGaussDoubleSidedExp.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "Math/ProbFuncMathCore.h"

ClassImp(RooGaussDoubleSidedExp) 


//_____________________________________________________________________________
RooGaussDoubleSidedExp::RooGaussDoubleSidedExp(const char *name, const char *title, 
					       RooAbsReal& _m,
					       RooAbsReal& _m0,
					       RooAbsReal& _sigma,
					       RooAbsReal& _alphaLo,
					       RooAbsReal& _alphaHi
					       ) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  m0("m0","m0",this,_m0),
  sigma("sigma","sigma",this,_sigma),
  alphaLo("alphaLo","alphaLo",this,_alphaLo),
  alphaHi("alphaHi","alphaHi",this,_alphaHi)
{ 
} 


//_____________________________________________________________________________
RooGaussDoubleSidedExp::RooGaussDoubleSidedExp(const RooGaussDoubleSidedExp& other, const char* name) :  
  RooAbsPdf(other,name), 
  m("m",this,other.m),
  m0("m0",this,other.m0),
  sigma("sigma",this,other.sigma),
  alphaLo("alphaLo",this,other.alphaLo),
  alphaHi("alphaHi",this,other.alphaHi)
{ 
} 


//_____________________________________________________________________________
Double_t RooGaussDoubleSidedExp::evaluate() const 
{
   Double_t t=(m-m0)/sigma;

   if (t<-alphaLo)
     return exp(alphaLo*alphaLo/2.+alphaLo*t);
   else if (t>alphaHi)
     return exp(alphaHi*alphaHi/2.-alphaHi*t);
   else
     return exp(-0.5*t*t);
} 


//_____________________________________________________________________________
Int_t RooGaussDoubleSidedExp::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  if( matchArgs(allVars,analVars,m) )
    return 1;
 
  return 0;
}


//_____________________________________________________________________________
Double_t RooGaussDoubleSidedExp::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code==1);
  double result = 0;
   
  double sig = fabs((Double_t)sigma);
  double tmin = (m.min(rangeName)-m0)/sig;
  double tmax = (m.max(rangeName)-m0)/sig;
  
  if (tmin < -alphaLo)
    result += tailIntegral(tmin, TMath::Min(tmax, -alphaLo), alphaLo);
  if (tmin < alphaHi && tmax > -alphaLo)
    result += gaussianIntegral(TMath::Max(tmin, -alphaLo), TMath::Min(tmax, alphaHi));
  if (tmax > alphaHi)
    result += tailIntegral(TMath::Max(tmin, alphaHi), tmax, -alphaHi);

 return sig*result;
}

//_____________________________________________________________________________
double RooGaussDoubleSidedExp::gaussianIntegral(double tmin, double tmax) const
{
  return sqrt(TMath::TwoPi())*(ROOT::Math::gaussian_cdf(tmax) - ROOT::Math::gaussian_cdf(tmin));
}

//_____________________________________________________________________________
double RooGaussDoubleSidedExp::tailIntegral(double tmin, double tmax, double alpha) const
{
  double a = exp(0.5*alpha*alpha)/alpha;
  return (a*(exp(alpha*tmax)-exp(alpha*tmin)));
}
