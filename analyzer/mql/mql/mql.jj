/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./mql.jj */
/*@egen*//*
 * This file defines the lexical structure and the grammar for MQL (the
 * "Muon Query Language").  It is formatted as input to the JavaCC tool,
 * which uses it to build a parser for MQL.
 *
 * Much of what follows is modeled on and/or copied from various
 * example files that accompany JavaCC.  The following legal notice
 * appears at the top of those files:
 *

 Copyright \ufffd 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 intellectual property rights relating to technology embodied in the product
 that is described in this document. In particular, and without limitation,
 these intellectual property rights may include one or more of the U.S.
 patents listed at http://www.sun.com/patents and one or more additional
 patents or pending patent applications in the U.S. and in other countries.
 U.S. Government Rights - Commercial software. Government users are subject
 to the Sun Microsystems, Inc. standard license agreement and applicable
 provisions of the FAR and its supplements.  Use is subject to license terms.
 Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 product is covered and controlled by U.S. Export Control laws and may be
 subject to the export or import laws in other countries.  Nuclear, missile,
 chemical biological weapons or nuclear maritime end uses or end users, whether
 direct or indirect, are strictly prohibited.  Export or reexport to countries
 subject to U.S. embargo or to entities identified on U.S. export exclusion
 lists, including, but not limited to, the denied persons and specially
 designated nationals lists is strictly prohibited.

 *
 * However, the distribution site http://javacc.dev.java.net/, which appears
 * to be owned by Sun Microsystems, Inc., states that the project is licensed
 * under the  Berkeley Software Distribution (BSD) License, with a link to
 * http://www.opensource.org/licenses/bsd-license.html, which reads as follows:
 *

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice, 
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.
  * Neither the name of the <ORGANIZATION> nor the names of its contributors 
    may be used to endorse or promote products derived from this software 
    without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.

 *
 * Consequently, I conclude that it's OK to copy this stuff.
 */

options {
  JAVA_UNICODE_ESCAPE = true;                                   
}

PARSER_BEGIN(MqlParser)

import java.io.*;

public class MqlParser/*@bgen(jjtree)*/implements MqlParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTMqlParserState jjtree = new JJTMqlParserState();

/*@egen*/
  public static void main(String args[]) {
    try {
      FileReader inputFile = new FileReader(args[0]);
      MqlParser t = new MqlParser(inputFile);
      SimpleNode n = t.Root();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
}

PARSER_END(MqlParser)

/*
 * The next part defines the lexical analyzer that breaks up the input 
 * into tokens.  This "lexing" is the step before the actual parsing.
 */

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN: /* RESERVED WORDS AND LITERALS */
{
  < IMPORT: "import" >
| < NTUPLE_IMPORT: "ntuple_import" >
| < EXPORT: "export" >
| < SELECT: "select" >
| < JOIN: "join" >
| < CLUSTER: "cluster" >
| < NTUPLE: "ntuple" >
| < MERGE: "merge" >
| < HISTOGRAM1D: "histogram1d" >
| < HISTOGRAMS1D: "histograms1d" >
| < HISTOGRAM2D: "histogram2d" >
| < HISTOGRAMS2D: "histograms2d" >
| < HISTOGRAM3D: "histogram3d" >
| < HISTOGRAMS3D: "histograms3d" >
| < LITERAL: "literal" >

| < MODULE: "module" >

| < BOOL: "bool" >
| < BYTE: "byte" >
| < SHORT: "short" >
| < INT: "int" >
| < FLOAT: "float" >
| < DOUBLE: "double" >
| < STRUCT: "struct" >

| < FROM: "from" >
| < TO: "to" >
| < BINS: "bins" >
| < INTO: "into" >
| < WHERE: "where" >
| < ENABLE: "enable" >
| < COINCIDENCE: "coincidence" >
| < WITH: "with" >
| < MODULO: "modulo" >
| < NAME: "name" >
| < TITLE: "title" >
| < UNIQUE: "unique" >
| < NON_TRANSITIVE: "non_transitive" >
| < INVERT: "invert" >
| < ORDER: "order" >
| < BY: "by" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: (["+","-"])? ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["+","-"])? (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | (["+","-"])? "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["+","-"])? (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["+","-"])? (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
//      (   (~["\"","\\","\n","\r"])
      (   (~["\"","\\"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* IDENTIFIERS */
{ 
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| 
  < #LETTER: 
      [ 
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  > 
| 
  < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f", 
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

TOKEN : /* SEPARATORS */
{
 < SEMICOLON: ";" >
}

/*
 * Here begins the actual grammar for MQL.
 */

MqlRoot Root() : {/*@bgen(jjtree) Root */
  MqlRoot jjtn000 = new MqlRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Root */
  try {
/*@egen*/
  ModuleDeclaration()
  ( Statement() )*
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/

  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ModuleDeclaration() : {/*@bgen(jjtree) ModuleDeclaration */
  MqlModuleDeclaration jjtn000 = new MqlModuleDeclaration(JJTMODULEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ModuleDeclaration */
  try {
/*@egen*/
  "module" Identifier() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Statement()       : { }
{
  ImportStatement()
| NtupleImportStatement()
| ExportStatement()
| SelectStatement()
| JoinStatement() 
| ClusterStatement() 
| MergeStatement()
| NtupleStatement()
| Histogram1DStatement()
| Histograms1DStatement()
| Histogram2DStatement()
| Histograms2DStatement()
| Histogram3DStatement()
| Histograms3DStatement()
| LiteralStatement()
}

void BankName() : {/*@bgen(jjtree) BankName */
  MqlBankName jjtn000 = new MqlBankName(JJTBANKNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BankName */
  try {
/*@egen*/
  Identifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void Type() : {/*@bgen(jjtree) Type */
  MqlType jjtn000 = new MqlType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Type */
   try {
/*@egen*/
   ("bool"/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { jjtn000.set(MqlType.BOOLEAN); })
 | ("byte"/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { jjtn000.set(MqlType.BYTE); })
 | ("short"/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ { jjtn000.set(MqlType.SHORT); })
 | ("int"/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/    { jjtn000.set(MqlType.INTEGER); })
 | ("float"/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ { jjtn000.set(MqlType.FLOAT); })
 | ("double"/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.set(MqlType.DOUBLE); })
 | ("struct" Identifier()/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ { jjtn000.set(MqlType.STRUCT); })/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/

}

void ColumnEntry() : {/*@bgen(jjtree) ColumnEntry */
  MqlColumnEntry jjtn000 = new MqlColumnEntry(JJTCOLUMNENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ColumnEntry */
  try {
/*@egen*/
  [ Type() ] Identifier() [ "=" Expression() ] [ "," ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ColumnList() : {/*@bgen(jjtree) ColumnList */
  MqlColumnList jjtn000 = new MqlColumnList(JJTCOLUMNLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ColumnList */
  try {
/*@egen*/
  "{" ( ColumnEntry() )* "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  MqlExpression jjtn000 = new MqlExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  Identifier()
|
  StringLiteral()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void ImportStatement() : {/*@bgen(jjtree) ImportStatement */
  MqlImportStatement jjtn000 = new MqlImportStatement(JJTIMPORTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ImportStatement */
  try {
/*@egen*/
  "import" TableName() "from" BankName() ColumnList() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void NtupleImportStatement() : {/*@bgen(jjtree) NtupleImportStatement */
  MqlNtupleImportStatement jjtn000 = new MqlNtupleImportStatement(JJTNTUPLEIMPORTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NtupleImportStatement */
  try {
/*@egen*/
  "ntuple_import" TableName() "from" TableName() ColumnList() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ExportStatement() : {/*@bgen(jjtree) ExportStatement */
  MqlExportStatement jjtn000 = new MqlExportStatement(JJTEXPORTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ExportStatement */
  try {
/*@egen*/
  "export" TableName() "to" BankName() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SelectStatement() : {/*@bgen(jjtree) SelectStatement */
  MqlSelectStatement jjtn000 = new MqlSelectStatement(JJTSELECTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SelectStatement */
  try {
/*@egen*/
  "select" "from" TableName()
  "into" TableName()
  ( SortExpression() | WhereExpression() | EnableExpression() )*
  [ ColumnList() ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void WhereExpression() : {/*@bgen(jjtree) WhereExpression */
  MqlWhereExpression jjtn000 = new MqlWhereExpression(JJTWHEREEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) WhereExpression */
  try {
/*@egen*/
  "where" Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void EnableExpression() : {/*@bgen(jjtree) EnableExpression */
  MqlEnableExpression jjtn000 = new MqlEnableExpression(JJTENABLEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) EnableExpression */
  try {
/*@egen*/
  "enable" Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ModuloExpression() : {/*@bgen(jjtree) ModuloExpression */
  MqlModuloExpression jjtn000 = new MqlModuloExpression(JJTMODULOEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ModuloExpression */
  try {
/*@egen*/
  "modulo" Identifier() "from" NumericalExpression() "to" NumericalExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SortExpression() : {/*@bgen(jjtree) SortExpression */
  MqlSortExpression jjtn000 = new MqlSortExpression(JJTSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SortExpression */
  try {
/*@egen*/
  "order" "by" Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CoincExpression() : {/*@bgen(jjtree) CoincExpression */
  MqlCoincExpression jjtn000 = new MqlCoincExpression(JJTCOINCEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) CoincExpression */
  try {
/*@egen*/
  "coincidence" Identifier() "with" Identifier() "from" 
  NumericalExpression() "to" NumericalExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void UniqueOption() : {/*@bgen(jjtree) UniqueOption */
  MqlUniqueOption jjtn000 = new MqlUniqueOption(JJTUNIQUEOPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) UniqueOption */
  try {
/*@egen*/
  "unique"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void InvertOption() : {/*@bgen(jjtree) InvertOption */
  MqlInvertOption jjtn000 = new MqlInvertOption(JJTINVERTOPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) InvertOption */
  try {
/*@egen*/
  "invert"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void NonTransitiveOption() : {/*@bgen(jjtree) NonTransitiveOption */
  MqlNonTransitiveOption jjtn000 = new MqlNonTransitiveOption(JJTNONTRANSITIVEOPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NonTransitiveOption */
  try {
/*@egen*/
  "non_transitive"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void JoinStatement() : {/*@bgen(jjtree) JoinStatement */
  MqlJoinStatement jjtn000 = new MqlJoinStatement(JJTJOINSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) JoinStatement */
  try {
/*@egen*/
  "join" TableName()
  "with" TableName()
  "into" TableName()
  [ UniqueOption() | InvertOption() ]
  [ CoincExpression() ]
  ( SortExpression() | WhereExpression() | EnableExpression() )*
  [ ColumnList() ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ClusterStatement() : {/*@bgen(jjtree) ClusterStatement */
  MqlClusterStatement jjtn000 = new MqlClusterStatement(JJTCLUSTERSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ClusterStatement */
  try {
/*@egen*/
  "cluster" "from" TableName()
  "into" TableName()
  [ NonTransitiveOption() ]
  [ CoincExpression() ]
  [ ModuloExpression() ]
  ( SortExpression() | WhereExpression() | EnableExpression() )*
  [ ColumnList() ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MergeStatement() : {/*@bgen(jjtree) MergeStatement */
  MqlMergeStatement jjtn000 = new MqlMergeStatement(JJTMERGESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MergeStatement */
  try {
/*@egen*/
  "merge" TableName()
  ( "with" TableName() )*
  "into" TableName()
  ( SortExpression() | WhereExpression() | EnableExpression() )*
  [ ColumnList() ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void NtupleStatement() : {/*@bgen(jjtree) NtupleStatement */
  MqlNtupleStatement jjtn000 = new MqlNtupleStatement(JJTNTUPLESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NtupleStatement */
  try {
/*@egen*/
  "ntuple" "from" TableName()
  HistName() [ HistTitle() ]
  ( WhereExpression() | EnableExpression() )*
  [ ColumnList() ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Number()         : 
{/*@bgen(jjtree) String */
  MqlString jjtn000 = new MqlString(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ 
  Token t;
}
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  ( t=<INTEGER_LITERAL>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { jjtn000.set(t.image); } )
  | ( t=<FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn000, true);
                                   jjtc000 = false;
                                 }
/*@egen*/ { jjtn000.set(t.image); } )/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void NumericalExpression() : {/*@bgen(jjtree) NumericalExpression */
  MqlNumericalExpression jjtn000 = new MqlNumericalExpression(JJTNUMERICALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NumericalExpression */
  try {
/*@egen*/
  Number() 
|
  StringLiteral()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void Axis() : {/*@bgen(jjtree) Axis */
  MqlAxis jjtn000 = new MqlAxis(JJTAXIS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Axis */
  try {
/*@egen*/
  Expression() 
  "bins" NumericalExpression()
  "from" NumericalExpression() 
  "to" NumericalExpression()
  [ HistTitle() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void HistogramSelector() : {/*@bgen(jjtree) HistogramSelector */
  MqlHistogramSelector jjtn000 = new MqlHistogramSelector(JJTHISTOGRAMSELECTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) HistogramSelector */
  try {
/*@egen*/
  "select"
  Expression() 
  "from" NumericalExpression() 
  "to" NumericalExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void StringLiteral()         :
{/*@bgen(jjtree) String */
  MqlString jjtn000 = new MqlString(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  t=<STRING_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // Delete the leading and trailing quotation marks
    String s = t.image;
    jjtn000.set(s.substring(1, s.length() - 1)); 
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Identifier()         :
{/*@bgen(jjtree) String */
  MqlString jjtn000 = new MqlString(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  t=<IDENTIFIER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.set(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void HistName() : {/*@bgen(jjtree) HistName */
  MqlHistName jjtn000 = new MqlHistName(JJTHISTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) HistName */
  try {
/*@egen*/
  "name" StringLiteral()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void HistTitle() : {/*@bgen(jjtree) HistTitle */
  MqlHistTitle jjtn000 = new MqlHistTitle(JJTHISTTITLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) HistTitle */
  try {
/*@egen*/
  "title" StringLiteral()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void TableName() : {/*@bgen(jjtree) TableName */
  MqlTableName jjtn000 = new MqlTableName(JJTTABLENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) TableName */
  try {
/*@egen*/
  Identifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Histogram1DStatement() : {/*@bgen(jjtree) Histogram1DStatement */
  MqlHistogram1DStatement jjtn000 = new MqlHistogram1DStatement(JJTHISTOGRAM1DSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Histogram1DStatement */
  try {
/*@egen*/
  "histogram1d" "from" TableName()
  ( WhereExpression() | EnableExpression() )*
  HistName() [ HistTitle() ]
  Axis() 
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Histograms1DStatement() : {/*@bgen(jjtree) Histograms1DStatement */
  MqlHistograms1DStatement jjtn000 = new MqlHistograms1DStatement(JJTHISTOGRAMS1DSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Histograms1DStatement */
  try {
/*@egen*/
  "histograms1d" "from" TableName()
  ( WhereExpression() | EnableExpression() )*
  HistName() [ HistTitle() ]
  HistogramSelector()
  Axis() 
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Histogram2DStatement() : {/*@bgen(jjtree) Histogram2DStatement */
  MqlHistogram2DStatement jjtn000 = new MqlHistogram2DStatement(JJTHISTOGRAM2DSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Histogram2DStatement */
  try {
/*@egen*/
  "histogram2d" "from" TableName()
  ( WhereExpression() | EnableExpression() )*
  HistName() [ HistTitle() ]
  Axis() 
  Axis() 
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Histograms2DStatement() : {/*@bgen(jjtree) Histograms2DStatement */
  MqlHistograms2DStatement jjtn000 = new MqlHistograms2DStatement(JJTHISTOGRAMS2DSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Histograms2DStatement */
  try {
/*@egen*/
  "histograms2d" "from" TableName()
  ( WhereExpression() | EnableExpression() )*
  HistName() [ HistTitle() ]
  HistogramSelector()
  Axis() 
  Axis() 
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void Histogram3DStatement() : {/*@bgen(jjtree) Histogram3DStatement */
  MqlHistogram3DStatement jjtn000 = new MqlHistogram3DStatement(JJTHISTOGRAM3DSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Histogram3DStatement */
  try {
/*@egen*/
  "histogram3d" "from" TableName()
  ( WhereExpression() | EnableExpression() )*
  HistName() [ HistTitle() ]
  Axis() 
  Axis() 
  Axis() 
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Histograms3DStatement() : {/*@bgen(jjtree) Histograms3DStatement */
  MqlHistograms3DStatement jjtn000 = new MqlHistograms3DStatement(JJTHISTOGRAMS3DSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Histograms3DStatement */
  try {
/*@egen*/
  "histograms3d" "from" TableName()
  ( WhereExpression() | EnableExpression() )*
  HistName() [ HistTitle() ]
  HistogramSelector()
  Axis() 
  Axis() 
  Axis() 
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void LiteralStatement() : {/*@bgen(jjtree) LiteralStatement */
  MqlLiteralStatement jjtn000 = new MqlLiteralStatement(JJTLITERALSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) LiteralStatement */
  try {
/*@egen*/
  "literal" Expression() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
